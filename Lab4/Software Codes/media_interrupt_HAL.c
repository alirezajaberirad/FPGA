#include "globals.h"

/* these globals are written by interrupt service routines; we have to declare
 * these as volatile to avoid the compiler caching their values in registers */
extern volatile unsigned char byte1, byte2, byte3;	/* modified by PS/2 interrupt service routine */
extern volatile int timeout;								// used to synchronize with the timer
extern unsigned char bottons_stat;//status of the mouse bottons
extern int mouse_x;//horizontal location of the mouse in the screen
extern int mouse_y;//vertical location of the mouse in the screen
extern int screen_max_x;
extern int screen_max_y;
extern short cursor_shape[16][8];//this is a 2D array that stores the shape of the cursor
extern struct alt_up_dev up_dev;							/* pointer to struct that holds pointers to open devices */
extern volatile int buf_index_record;
extern volatile int buf_index_play;
extern volatile int echo_en;
extern volatile char* command;
extern const int B[64];

extern volatile short make_echo_flag;
extern unsigned int l_buf[BUF_SIZE];					// audio buffer
extern unsigned int r_buf[BUF_SIZE];					// audio buffer
extern unsigned int l_buf_echo[BUF_SIZE];
extern unsigned int r_buf_echo[BUF_SIZE];
extern double coeffs[64];
//extern volatile unsigned int* acc_base_addr;
extern volatile int N;
extern volatile unsigned long long int avg[25];
extern volatile unsigned long long int hw_avg[25];
extern volatile int play_en;
extern volatile int col_size;

/* function prototypes */
void plot_audio(alt_up_pixel_buffer_dma_dev*);
void calc_avg();
//void amplitude_circute_stop();
//void amplitude_circute_get_status();

// void amplitude_circute_set_size(unsigned int);
// void amplitude_circute_set_num(unsigned int);
// void amplitude_circute_set_rbuff_addr(volatile unsigned int*);
// void amplitude_circute_set_lbuff_addr(volatile unsigned int*);
// void amplitude_circute_set_dest_addr(volatile unsigned long long int*);
// void amplitude_circute_start();
// void amplitude_operation(unsigned int, unsigned int, volatile unsigned int*, volatile unsigned int*, volatile unsigned long long int*);
extern void amplitude_operation(unsigned int, unsigned int, volatile unsigned int*, volatile unsigned int*, volatile unsigned long long int*);
void HEX_PS2(unsigned char, unsigned char, unsigned char);
void command_detector(unsigned char, alt_up_audio_dev *);
void record_play_echo(alt_up_audio_dev *);
void make_echo();
unsigned char give_bottons_stat(unsigned char, unsigned char, unsigned char);//gives the status of mouse bottons
void mouseLocation(unsigned char, unsigned char, unsigned char);//sets the value of mouse_x and mouse_y to indicate the location of the mouse cursor in the screen
void interval_timer_ISR(void *, unsigned int);
void pushbutton_ISR(void *, unsigned int);
void audio_ISR(void *, unsigned int);
void PS2_ISR(void *, unsigned int);
void coeffs_to_float();
//void draw_mouse(alt_up_dev *);

/********************************************************************************
 * This program demonstrates use of the media ports in the DE2 Media Computer
 *
 * It performs the following:
 *  	1. records audio for about 10 seconds when an interrupt is generated by
 *  	   pressing KEY[1]. LEDG[0] is lit while recording. Audio recording is
 *  	   controlled by using interrupts
 * 	2. plays the recorded audio when an interrupt is generated by pressing
 * 	   KEY[2]. LEDG[1] is lit while playing. Audio playback is controlled by
 * 	   using interrupts
 * 	3. Draws a blue box on the VGA display, and places a text string inside
 * 	   the box. Also, moves the word ALTERA around the display, "bouncing" off
 * 	   the blue box and screen edges
 * 	4. Shows a text message on the LCD display, and scrolls the message
 * 	5. Displays the last three bytes of data received from the PS/2 port
 * 	   on the HEX displays on the DE2 board. The PS/2 port is handled using
 * 	   interrupts
 * 	6. The speed of scrolling the LCD display and of refreshing the VGA screen
 * 	   are controlled by interrupts from the interval timer
********************************************************************************/
int main(void)
{
	/* declare device driver pointers for devices */
	alt_up_parallel_port_dev *KEY_dev;//pointer for Keys
	alt_up_parallel_port_dev *green_LEDs_dev;//pointer for green LEDs
	alt_up_parallel_port_dev *red_LEDs_dev;//pointer for red LEDs
	alt_up_ps2_dev *PS2_dev;//pointer for mouse
	alt_up_character_lcd_dev *lcd_dev;//pointer for the onboard lcd
	alt_up_audio_dev *audio_dev;
	alt_up_char_buffer_dev *char_buffer_dev;
	alt_up_pixel_buffer_dma_dev *pixel_buffer_dev;
	/* declare volatile pointer for interval timer, which does not have HAL functions */
	volatile int * interval_timer_ptr = (int *) 0x10002000;	// interal timer base address

	/* initialize some variables */
	byte1 = 0; byte2 = 0; byte3 = 0; 			// used to hold PS/2 data
	timeout = 0;										// synchronize with the timer

	//TIMER
	alt_u32 timestamp_freq;


	/* these variables are used for a blue box and a "bouncing" ALTERA on the VGA screen */
	int record_x1; int record_y1; int record_x2; int record_y2;
	int play_x1; int play_y1; int play_x2; int play_y2;
	int echo_x1; int echo_y1; int echo_x2; int echo_y2;
	short color;
	unsigned int size=BUF_SIZE/N;
	unsigned int status;

	/* set the interval timer period for scrolling the HEX displays */
	int counter = 0x960000;				// 1/(50 MHz) x (0x960000) ~= 200 msec
	*(interval_timer_ptr + 0x2) = (counter & 0xFFFF);
	*(interval_timer_ptr + 0x3) = (counter >> 16) & 0xFFFF;

	/* start interval timer, enable its interrupts */
	*(interval_timer_ptr + 1) = 0x7;	// STOP = 0, START = 1, CONT = 1, ITO = 1

	// open the pushbuttom KEY parallel port
	KEY_dev = alt_up_parallel_port_open_dev ("/dev/Pushbuttons");
	if ( KEY_dev == NULL)
	{
		alt_printf ("Error: could not open pushbutton KEY device\n");
		return -1;
	}
	else
	{
		alt_printf ("Opened pushbutton KEY device\n");
		up_dev.KEY_dev = KEY_dev;	// store for use by ISRs
	}
	/* write to the pushbutton interrupt mask register, and set 3 mask bits to 1
	 * (bit 0 is Nios II reset) */
	alt_up_parallel_port_set_interrupt_mask (KEY_dev, 0xE);

	// open the green LEDs parallel port
	green_LEDs_dev = alt_up_parallel_port_open_dev ("/dev/Green_LEDs");
	if ( green_LEDs_dev == NULL)
	{
		alt_printf ("Error: could not open green LEDs device\n");
		return -1;
	}
	else
	{
		alt_printf ("Opened green LEDs device\n");
		up_dev.green_LEDs_dev = green_LEDs_dev;	// store for use by ISRs
	}

	// open the red LEDs parallel port
	red_LEDs_dev = alt_up_parallel_port_open_dev ("/dev/Red_LEDs");
	if ( red_LEDs_dev == NULL)
	{
		alt_printf ("Error: could not open red LEDs device\n");
		return -1;
	}
	else
	{
		alt_printf ("Opened red LEDs device\n");
		up_dev.red_LEDs_dev = red_LEDs_dev;	// store for use by ISRs
	}

	// open the PS2 port
	PS2_dev = alt_up_ps2_open_dev ("/dev/PS2_Port");
	if ( PS2_dev == NULL)
	{
		alt_printf ("Error: could not open PS2 device\n");
		return -1;
	}
	else
	{
		alt_printf ("Opened PS2 device\n");
		up_dev.PS2_dev = PS2_dev;	// store for use by ISRs
	}
	(void) alt_up_ps2_write_data_byte (PS2_dev, 0xFF);		// reset
	alt_up_ps2_enable_read_interrupt (PS2_dev); // enable interrupts from PS/2 port

	// open the audio port
	audio_dev = alt_up_audio_open_dev ("/dev/Audio");
	if ( audio_dev == NULL)
	{
		alt_printf ("Error: could not open audio device\n");
		return -1;
	}
	else
	{
		alt_printf ("Opened audio device\n");
		up_dev.audio_dev = audio_dev;	// store for use by ISRs
	}

	// open the 16x2 character display port
	lcd_dev = alt_up_character_lcd_open_dev ("/dev/Char_LCD_16x2");
	if ( lcd_dev == NULL)
	{
		alt_printf ("Error: could not open character LCD device\n");
		return -1;
	}
	else
	{
		alt_printf ("Opened character LCD device\n");
		up_dev.lcd_dev = lcd_dev;	// store for use by ISRs
	}

	/* use the HAL facility for registering interrupt service routines. */
	/* Note: we are passsing a pointer to up_dev to each ISR (using the context argument) as
	 * a way of giving the ISR a pointer to every open device. This is useful because some of the
	 * ISRs need to access more than just one device (e.g. the pushbutton ISR accesses both
	 * the pushbutton device and the audio device) */
	alt_irq_register (0, (void *) &up_dev, (void *) interval_timer_ISR);
	alt_irq_register (1, (void *) &up_dev, (void *) pushbutton_ISR);
	alt_irq_register (6, (void *) &up_dev, (void *) audio_ISR);
	alt_irq_register (7, (void *) &up_dev, (void *) PS2_ISR);

	/* create a messages to be displayed on the VGA and LCD displays */
	char text_top_LCD[80] = "Welcome to the DE2 Media Computer...\0";

	/* output text message to the LCD */
	alt_up_character_lcd_set_cursor_pos (lcd_dev, 0, 0);	// set LCD cursor location to top row
	alt_up_character_lcd_string (lcd_dev, text_top_LCD);
	alt_up_character_lcd_cursor_off (lcd_dev);				// turn off the LCD cursor

	/* open the pixel buffer */
	pixel_buffer_dev = alt_up_pixel_buffer_dma_open_dev ("/dev/VGA_Pixel_Buffer");
	if ( pixel_buffer_dev == NULL)
		alt_printf ("Error: could not open pixel buffer device\n");
	else
		alt_printf ("Opened pixel buffer device\n");



	//Background
	color=0;
	alt_up_pixel_buffer_dma_draw_box (pixel_buffer_dev, 0, 0, screen_max_x,
		screen_max_y, color, 0); // fill the screen







	/* output text message in the middle of the VGA monitor */
	char_buffer_dev = alt_up_char_buffer_open_dev ("/dev/VGA_Char_Buffer");
	if ( char_buffer_dev == NULL)
		alt_printf ("Error: could not open character buffer device\n");
	else
		alt_printf ("Opened character buffer device\n");



	/*openning coefficients file*/
	int i,j;/*
	FILE *myFile;
	myFile = fopen("coefficients.txt","r");
	for(i=0;i<64;i++){
		fscanf(myFile,"%lf",&coeffs[i]);
	}*/

	coeffs_to_float();
	printf("first coefficient: %.5f\n",coeffs[0]);


	while (1)
	{
		//while (!timeout)
			//;	// wait to synchronize with timeout, which is set by the interval timer ISR

		/***************Boxes**************/
		//Record Botton
		color=0x187F;
		record_x1=40; record_y1=50; record_x2=70; record_y2=70;
		alt_up_pixel_buffer_dma_draw_box (pixel_buffer_dev, record_x1 , record_y1 , record_x2 ,
			record_y2, color, 0);

		//Play Botton
		play_x1=140; play_y1=50; play_x2=170; play_y2=70;
		alt_up_pixel_buffer_dma_draw_box (pixel_buffer_dev, play_x1 , play_y1 , play_x2 ,
			play_y2, color, 0);

		//Echo Botton
		echo_x1=240; echo_y1=50; echo_x2=270; echo_y2=70;
		alt_up_pixel_buffer_dma_draw_box (pixel_buffer_dev, echo_x1 , echo_y1 , echo_x2 ,
			echo_y2, color, 0);


		/*************Texts in the boxes*************/
		alt_up_char_buffer_string (char_buffer_dev, "Record\0", record_x1/4 + 1, record_y1/4 + 3);
		alt_up_char_buffer_string (char_buffer_dev, "Play\0", play_x1/4 + 1, play_y1/4 + 3);
		alt_up_char_buffer_string (char_buffer_dev, "Echo\0", echo_x1/4 + 1, echo_y1/4 + 3);

		/* also, display any PS/2 data (from its interrupt service routine) on HEX displays */
		HEX_PS2 (byte1, byte2, byte3);

		bottons_stat=give_bottons_stat(byte1,byte2,byte3);//determines status of the mouse bottons
		alt_up_parallel_port_write_data (up_dev.red_LEDs_dev, bottons_stat);

		if(make_echo_flag){
			//alt_timestamp_start();
			timestamp_freq=alt_timestamp_freq();
			if(timestamp_freq == 0)
				printf("timestamp hardware not working\n");
			printf("Calculation Started...\n");

			//Software average calculations
			alt_timestamp_start();
			calc_avg();
			printf("Software Calculation Finished in %.3f seconds\n", (float)alt_timestamp()/(float)timestamp_freq);

			//Hardware average calculations
			alt_timestamp_start();
			amplitude_operation((unsigned int)BUF_SIZE/N, N, r_buf, l_buf, hw_avg);
			printf("Hardware Calculation Finished in %.3f seconds\n", (float)alt_timestamp()/(float)timestamp_freq);

			plot_audio(pixel_buffer_dev);
			//make_echo();
			//amplitude_operation(BUF_SIZE/N, N, r_buf, l_buf, dest_addr);
			make_echo_flag=0;
		}

		if(buf_index_play != 0){
			color=0x00ff;
			status=buf_index_play/size;
			alt_up_pixel_buffer_dma_draw_box(pixel_buffer_dev, status*col_size+2, 235, (status+1)*col_size-3, 226, color, 0);
		}

		/*scanf("%s", command);	*/

		command_detector(bottons_stat,audio_dev);
		record_play_echo(audio_dev);

		for(j=0;j<8;j++){//clear previous mouse cursor
			for(i=0;i<16;i++){
				if(cursor_shape[i][j]!= -1)
					alt_up_pixel_buffer_dma_draw(pixel_buffer_dev,0,mouse_x+j, mouse_y+i);
			}
		}

		mouseLocation(byte1,byte2,byte3);//calculates the location of the mouse cursor in the screen

		for(j=0;j<8;j++){//print mouse cursor
			for(i=0;i<16;i++){
				if(cursor_shape[i][j]!= -1)
					alt_up_pixel_buffer_dma_draw(pixel_buffer_dev,cursor_shape[i][j]*(-1),mouse_x+j, mouse_y+i);
			}
		}


		//timeout = 0;

	}
}

void plot_audio(alt_up_pixel_buffer_dma_dev* pixel_buffer_dev){
	short color;
	int i;
	unsigned int size=BUF_SIZE/N;
	int scale=0;
	unsigned long long int max_avg=0;

	for(i=0;i<N;i++){//SUM -> AVG
		hw_avg[i]=hw_avg[i]/size;
	}

	for(i=0;i<N;i++){
		avg[i]=avg[i]/size;
		printf("Sofware Calculation Result: %llu\nHardware Calculation Result: %llu\n",avg[i],hw_avg[i]);
	}

	for(i=0;i<N;i++){
		if(max_avg<hw_avg[i])
			max_avg=hw_avg[i];
	}

	scale = max_avg/100;
    color = 0xff00;
    for(i = 0; i < N; i++){
    	alt_up_pixel_buffer_dma_draw_box (pixel_buffer_dev, i * col_size + 2, 225, ((i+1) * col_size)-3 ,(225 - (hw_avg[i] / scale)), color, 0);
		}
    return;
}

void calc_avg(){
	int i,j;
	int size=BUF_SIZE/N;
	unsigned int temp;
	for(i=0;i<N;i++){
		avg[i]=0;
		for(j=0;j<size;j++){
			temp= ((l_buf[i*size+j] & 0x80000000) == 0x80000000) ? ((l_buf[i*size+j] ^ 0xffffffff)+1) : l_buf[i*size+j];
			avg[i]=avg[i]+(unsigned long long) temp;
		}
	}
	return;
}


void coeffs_to_float(){
	int i;
	for(i=0;i<64;i++)
		coeffs[i]=(float)B[i]/65536.0;
	return;
}


void command_detector(unsigned char bottons_stat, alt_up_audio_dev * audio_dev){
	if((bottons_stat>>2)%2){
		if(mouse_x>=40 && mouse_x<=70 && mouse_y>=110 && mouse_y<=130)
			command="Record\0";
		else if(mouse_x>=140 && mouse_x<=170 && mouse_y>=110 && mouse_y<=130)
			command="Play\0";
		else if(mouse_x>=240 && mouse_x<=270 && mouse_y>=110 && mouse_y<=130)
			command="Echo\0";
		else
			command="         \0";
	}
	else
		command="         \0";
	return;
}

void record_play_echo(alt_up_audio_dev * audio_dev){
			if(!strcmp(command,"Record")){
				// reset the buffer index for recording
				buf_index_record = 0;
				// clear audio FIFOs
				alt_up_audio_reset_audio_core (audio_dev);
				// enable audio-in interrupts
				alt_up_audio_enable_read_interrupt (audio_dev);
			}
			else if(!strcmp(command,"Play")){
				// reset counter to start playback
				echo_en=0;
				buf_index_play = 0;
				// clear audio FIFOs
				alt_up_audio_reset_audio_core (audio_dev);
				// enable audio-out interrupts
				alt_up_audio_enable_write_interrupt (audio_dev);
			}
			else if(!strcmp(command,"Echo")){
				// reset counter to start playback
				echo_en=1;
				buf_index_play = 0;
				// clear audio FIFOs
				alt_up_audio_reset_audio_core (audio_dev);
				// enable audio-out interrupts
				alt_up_audio_enable_write_interrupt (audio_dev);
			}
}

void mouseLocation(unsigned char b1, unsigned char b2, unsigned char b3){
	short overflow_x, overflow_y, sign_x, sign_y;
	//short speed;
	overflow_x=(b1>>6)%2;
	overflow_y=(b1>>7)%2;
	sign_x=(b1>>4)%2;
	sign_y=(b1>>5)%2;

	/*speed=1;
	b2=b2*speed;
	b3=b3*speed;*/

	//horizontal location
	if(sign_x){
		if(!overflow_x && (256-b2)<10)
			mouse_x=mouse_x -(256-b2);
	}
	else{
		if(!overflow_x && b2<10)
			mouse_x=mouse_x+b2;
	}
	if(mouse_x>screen_max_x)
		mouse_x=screen_max_x;
	else if(mouse_x<0)
		mouse_x=0;

	//vertical location
	if(sign_y){
		if(!overflow_y && (256-b3)<10)
			mouse_y=mouse_y+(256-b3);
	}
	else{
		if(!overflow_y && b3<10)
			mouse_y=mouse_y-b3;
	}
	if(mouse_y>screen_max_y)
		mouse_y=screen_max_y;
	else if(mouse_y<0)
		mouse_y=0;
}

unsigned char give_bottons_stat(unsigned char byte1, unsigned char byte2, unsigned char byte3){
	return ((byte1%2)<<2) | (((byte1/4)%2)<<1) | ((byte1/2)%2);
}

/****************************************************************************************
 * Subroutine to show a string of HEX data on the HEX displays
 * Note that we are using pointer accesses for the HEX displays parallel port. We could
 * also use the HAL functions for these ports instead
****************************************************************************************/
void HEX_PS2(unsigned char b1, unsigned char b2, unsigned char b3)
{
	volatile int *HEX3_HEX0_ptr = (int *) 0x10000020;
	volatile int *HEX7_HEX4_ptr = (int *) 0x10000030;

	/* SEVEN_SEGMENT_DECODE_TABLE gives the on/off settings for all segments in
	 * a single 7-seg display in the DE2 Media Computer, for the hex digits 0 - F */
	unsigned char	seven_seg_decode_table[] = {	0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07,
		  										0x7F, 0x67, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71 };
	unsigned char	hex_segs[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
	unsigned int shift_buffer, nibble;
	unsigned char code;
	int i;

	//////////////////////////////////////////////
	unsigned char seg7,seg6,seg54,seg3,seg2,seg10;//seg54 means segment 5 and segment 4 together, for seg10 the same property holds
	seg7=(b1>>4)%2;
	seg6=(b1>>6)%2;
	seg54=b2;
	seg3=(b1>>5)%2;
	seg2=(b1>>7)%2;
	seg10=b3;
	shift_buffer = (seg7 << 28) | (seg6 << 24) | (seg54 << 16) | (seg3 << 12) | (seg2 << 8) | seg10;
	//////////////////////////////////////////////

	for ( i = 0; i < 8; ++i )//end number changed from 6 to 8
	{
		nibble = shift_buffer & 0x0000000F;		// character is in rightmost nibble
		code = seven_seg_decode_table[nibble];
		hex_segs[i] = code;
		shift_buffer = shift_buffer >> 4;
	}
	/* drive the hex displays */
	*(HEX3_HEX0_ptr) = *(int *) (hex_segs);
	*(HEX7_HEX4_ptr) = *(int *) (hex_segs+4);
}
